{% extends 'markets/base.html' %}
{% load static %}

{% block title %}Dashboard - Arbitrage Analyzer{% endblock %}

{% block content %}
<div class="stats-grid">
    <div class="stat-card">
        <h3>Kalshi Events</h3>
        <div class="value">{{ kalshi_event_count }}</div>
    </div>
    <div class="stat-card">
        <h3>Polymarket Events</h3>
        <div class="value">{{ poly_event_count }}</div>
    </div>
    <div class="stat-card">
        <h3>Event Matches</h3>
        <div class="value green">{{ event_match_count }}</div>
    </div>
</div>

<!-- Tag Selection Section -->
<div class="section-header">
    <h2>Tag Selection</h2>
    <button class="btn" onclick="refreshTags()" id="refreshTagsBtn">
        Refresh Tags from API
        <span class="loading" id="refreshTagsLoading">...</span>
    </button>
</div>
<p class="section-description">Select tags to filter events when syncing. Leave empty to fetch all events.</p>

<div class="tag-filters">
    <div class="tag-filter-section">
        <div class="tag-section-header">
            <h3>Kalshi Tags</h3>
        </div>
        <div class="add-tag-form">
            <input type="text" id="kalshiTagInput" placeholder="New tag label..." class="tag-input">
            <input type="text" id="kalshiCategoryInput" placeholder="Category (optional)" class="tag-input category-input">
            <button class="btn-small" onclick="addTag('kalshi')">+ Add</button>
        </div>
        <div class="tag-select-container" id="kalshiTagsContainer">
            <div class="tag-checkboxes" id="kalshiTags">
                {% if kalshi_tags_by_category %}
                    {% for category, tags in kalshi_tags_by_category.items %}
                    <div class="tag-category">
                        <span class="category-label">{{ category }}</span>
                        <div class="category-tags">
                            {% for tag in tags %}
                            <label class="tag-checkbox">
                                <input type="checkbox" name="kalshi_tag" value="{{ tag.slug }}" data-label="{{ tag.label }}" data-tag-id="{{ tag.id }}">
                                <span class="tag-label">{{ tag.label }}</span>
                                <button class="tag-delete-btn" onclick="event.preventDefault(); deleteTag({{ tag.id }}, '{{ tag.label|escapejs }}')" title="Delete tag">&times;</button>
                            </label>
                            {% endfor %}
                        </div>
                    </div>
                    {% endfor %}
                {% else %}
                    <span class="no-tags">No tags available. Click "Refresh Tags from API" to fetch them.</span>
                {% endif %}
            </div>
        </div>
    </div>
    <div class="tag-filter-section">
        <div class="tag-section-header">
            <h3>Polymarket Tags</h3>
        </div>
        <div class="add-tag-form">
            <input type="text" id="polymarketTagInput" placeholder="Tag slug (e.g. crypto)..." class="tag-input">
            <button class="btn-small" onclick="addTag('polymarket')">+ Add</button>
        </div>
        <div class="tag-select-container" id="polymarketTagsContainer">
            <div class="tag-checkboxes" id="polymarketTags">
                {% if polymarket_tags %}
                <div class="category-tags">
                    {% for tag in polymarket_tags %}
                    <label class="tag-checkbox">
                        <input type="checkbox" name="polymarket_tag" value="{{ tag.external_id }}" data-label="{{ tag.label }}" data-tag-id="{{ tag.id }}">
                        <span class="tag-label">{{ tag.label }}</span>
                        <button class="tag-delete-btn" onclick="event.preventDefault(); deleteTag({{ tag.id }}, '{{ tag.label|escapejs }}')" title="Delete tag">&times;</button>
                    </label>
                    {% endfor %}
                </div>
                {% else %}
                    <span class="no-tags">No tags available. Click "Refresh Tags from API" to fetch them.</span>
                {% endif %}
            </div>
        </div>
    </div>
</div>

<!-- Manual Tag Match Section -->
<div class="manual-match-section">
    <button class="btn" onclick="createManualTagMatch()" id="manualMatchBtn">
        Create Manual Tag Match
        <span class="loading" id="manualMatchLoading">...</span>
    </button>
    <span class="help-text">Select one tag from Kalshi and one from Polymarket above, then click to create a match</span>
</div>

<!-- Matched Tags Section -->
<div class="section-header">
    <h2>Matched Tags</h2>
    <span class="page-info">{{ tag_match_count }} matches</span>
</div>

<div class="matched-tags-section">
    {% if tag_matches %}
    <div class="matched-tags-container">
        <div class="matched-tags-list">
            {% for match in tag_matches %}
            <div class="tag-match-item {% if match.is_manual %}manual-match{% endif %}">
                <span class="tag-badge kalshi">{{ match.kalshi_tag.label }}</span>
                <span class="match-arrow">&harr;</span>
                <span class="tag-badge polymarket">{{ match.polymarket_tag.label }}</span>
                <button class="tag-delete-btn" onclick="deleteTagMatch({{ match.id }})" title="Delete match">&times;</button>
            </div>
            {% endfor %}
        </div>
    </div>
    {% else %}
    <div class="empty-state">
        <p>No tag matches found. Select one Kalshi and one Polymarket tag and click "Create Manual Tag Match".</p>
    </div>
    {% endif %}
</div>

<!-- Event Sync Section -->
<div class="section-header">
    <h2>Event Sync</h2>
</div>
<p class="section-description">Sync events from both exchanges with optional date filtering.</p>

<div class="date-filter-section">
    <div class="date-filters">
        <div class="date-input-group">
            <label for="closeAfterDate">Closes After:</label>
            <input type="date" id="closeAfterDate" class="date-input">
        </div>
        <div class="date-input-group">
            <label for="closeBeforeDate">Closes Before:</label>
            <input type="date" id="closeBeforeDate" class="date-input">
        </div>
    </div>
    <div class="date-filters" style="margin-top: 12px;">
        <div class="date-input-group">
            <label for="syncVolumeMin">Min Volume ($):</label>
            <input type="number" id="syncVolumeMin" class="filter-input" placeholder="0" min="0">
        </div>
        <div class="date-input-group">
            <label for="syncVolumeMax">Max Volume ($):</label>
            <input type="number" id="syncVolumeMax" class="filter-input" placeholder="No limit" min="0">
        </div>
        <div class="date-input-group">
            <label for="syncLiquidityMin">Min Liquidity ($):</label>
            <input type="number" id="syncLiquidityMin" class="filter-input" placeholder="0" min="0">
        </div>
        <div class="date-input-group">
            <label for="syncLiquidityMax">Max Liquidity ($):</label>
            <input type="number" id="syncLiquidityMax" class="filter-input" placeholder="No limit" min="0">
        </div>
        <button class="btn-small" onclick="clearSyncFilters()">Clear All</button>
    </div>
</div>

<div class="action-buttons">
    <button class="btn primary" onclick="syncEvents()" id="syncBtn">
        Sync Events
        <span class="loading" id="syncLoading">...</span>
    </button>
    <button class="btn secondary" onclick="syncFromMatchedTags()" id="syncMatchedBtn">
        Sync from Matched Tags
        <span class="loading" id="syncMatchedLoading">...</span>
    </button>
</div>

<!-- Events Display Section -->
<div class="section-header">
    <h2>Events</h2>
</div>
<p class="section-description">Select one event from each exchange and click "Create Match" to manually match them.</p>

<div class="events-display">
    <div class="events-column">
        <h3>Kalshi Events ({{ kalshi_event_count }})</h3>
        <input type="text" id="kalshiEventSearch" placeholder="Search Kalshi events..." class="search-input" onkeyup="filterEvents('kalshi')">
        <div class="events-list" id="kalshiEventsList">
            {% for event in kalshi_events %}
            <div class="event-item" data-id="{{ event.id }}" onclick="selectEvent(this, 'kalshi')">
                <div class="event-title">
                    {% if event.url %}
                        <a href="{{ event.url }}" target="_blank" onclick="event.stopPropagation()">{{ event.title }}</a>
                    {% else %}
                        {{ event.title }}
                    {% endif %}
                </div>
                <div class="event-meta">
                    <span>Vol: ${{ event.volume|floatformat:0 }}</span>
                    {% if event.end_date %}<span>Ends: {{ event.end_date|slice:":10" }}</span>{% endif %}
                </div>
            </div>
            {% empty %}
            <p class="no-tags">No Kalshi events synced yet. Click "Sync Events" to fetch them.</p>
            {% endfor %}
        </div>
    </div>
    <div class="events-column">
        <h3>Polymarket Events ({{ poly_event_count }})</h3>
        <input type="text" id="polymarketEventSearch" placeholder="Search Polymarket events..." class="search-input" onkeyup="filterEvents('polymarket')">
        <div class="events-list" id="polymarketEventsList">
            {% for event in poly_events %}
            <div class="event-item" data-id="{{ event.id }}" onclick="selectEvent(this, 'polymarket')">
                <div class="event-title">
                    {% if event.url %}
                        <a href="{{ event.url }}" target="_blank" onclick="event.stopPropagation()">{{ event.title }}</a>
                    {% else %}
                        {{ event.title }}
                    {% endif %}
                </div>
                <div class="event-meta">
                    <span>Vol: ${{ event.volume|floatformat:0 }}</span>
                    {% if event.end_date %}<span>Ends: {{ event.end_date|slice:":10" }}</span>{% endif %}
                </div>
            </div>
            {% empty %}
            <p class="no-tags">No Polymarket events synced yet. Click "Sync Events" to fetch them.</p>
            {% endfor %}
        </div>
    </div>
</div>

<div class="manual-event-match-section">
    <button class="btn primary" onclick="createEventMatch()" id="createEventMatchBtn" disabled>
        Create Event Match
        <span class="loading" id="createEventMatchLoading">...</span>
    </button>
    <span class="help-text" id="selectedEventsInfo">Select one event from each exchange</span>
</div>

<!-- Event Matching Section -->
<div class="section-header">
    <h2>Event Matching</h2>
</div>
<p class="section-description">Semantically match events based on filter criteria.</p>

<div class="match-filter-section">
    <div class="match-filters">
        <div class="filter-input-group">
            <label for="volumeMin">Min Volume ($):</label>
            <input type="number" id="volumeMin" class="filter-input" placeholder="0">
        </div>
        <div class="filter-input-group">
            <label for="liquidityMin">Min Liquidity ($):</label>
            <input type="number" id="liquidityMin" class="filter-input" placeholder="0">
        </div>
    </div>
</div>

<div class="action-buttons">
    <button class="btn primary" onclick="refreshEventMatches()" id="refreshMatchesBtn">
        Refresh Opportunities
        <span class="loading" id="refreshMatchesLoading">...</span>
    </button>
</div>

<!-- Event Matches Table -->
<div class="section-header">
    <h2>Event Matches</h2>
    <span class="page-info">{{ total_event_matches }} total</span>
</div>

{% if event_matches %}
<table>
    <thead>
        <tr>
            <th>Kalshi Event</th>
            <th>Polymarket Event</th>
            <th class="sortable {% if current_sort == 'similarity_score' %}asc{% elif current_sort == '-similarity_score' %}desc{% endif %}"
                onclick="sortBy('similarity_score')">Score</th>
            <th class="sortable {% if current_sort == 'is_verified' %}asc{% elif current_sort == '-is_verified' %}desc{% endif %}"
                onclick="sortBy('is_verified')">Verified</th>
            <th>Actions</th>
        </tr>
    </thead>
    <tbody>
        {% for match in event_matches %}
        <tr data-match-id="{{ match.id }}">
            <td class="event-cell">
                {% if match.kalshi_event.url %}
                    <a href="{{ match.kalshi_event.url }}" target="_blank">{{ match.kalshi_event.title|truncatechars:60 }}</a>
                {% else %}
                    {{ match.kalshi_event.title|truncatechars:60 }}
                {% endif %}
            </td>
            <td class="event-cell">
                {% if match.polymarket_event.url %}
                    <a href="{{ match.polymarket_event.url }}" target="_blank">{{ match.polymarket_event.title|truncatechars:60 }}</a>
                {% else %}
                    {{ match.polymarket_event.title|truncatechars:60 }}
                {% endif %}
            </td>
            <td class="score-cell">
                <span class="score-badge {% if match.similarity_score >= 0.7 %}high{% elif match.similarity_score >= 0.5 %}medium{% else %}low{% endif %}">
                    {{ match.similarity_score|floatformat:2 }}
                </span>
            </td>
            <td>
                <span class="verified-badge {% if match.is_verified %}verified{% else %}unverified{% endif %}">
                    {{ match.is_verified|yesno:"Yes,No" }}
                </span>
            </td>
            <td class="actions-cell">
                <button class="btn-small" onclick="verifyEventMatch({{ match.id }})">
                    {% if match.is_verified %}Unverify{% else %}Verify{% endif %}
                </button>
                <button class="btn-small danger" onclick="deleteEventMatch({{ match.id }})">&times;</button>
            </td>
        </tr>
        {% endfor %}
    </tbody>
</table>

<!-- Pagination -->
{% if event_matches.has_other_pages %}
<div class="pagination">
    {% if event_matches.has_previous %}
    <a href="?page=1&sort={{ current_sort }}">First</a>
    <a href="?page={{ event_matches.previous_page_number }}&sort={{ current_sort }}">Prev</a>
    {% else %}
    <span class="disabled">First</span>
    <span class="disabled">Prev</span>
    {% endif %}

    {% for num in event_matches.paginator.page_range %}
        {% if event_matches.number == num %}
        <span class="current">{{ num }}</span>
        {% elif num > event_matches.number|add:'-3' and num < event_matches.number|add:'3' %}
        <a href="?page={{ num }}&sort={{ current_sort }}">{{ num }}</a>
        {% endif %}
    {% endfor %}

    {% if event_matches.has_next %}
    <a href="?page={{ event_matches.next_page_number }}&sort={{ current_sort }}">Next</a>
    <a href="?page={{ event_matches.paginator.num_pages }}&sort={{ current_sort }}">Last</a>
    {% else %}
    <span class="disabled">Next</span>
    <span class="disabled">Last</span>
    {% endif %}
</div>
{% endif %}

{% else %}
<div class="empty-state">
    <p>No event matches found.</p>
    <p>Sync events first, then click "Refresh Opportunities" to find matches.</p>
</div>
{% endif %}

<style>
    .section-description {
        color: #888;
        font-size: 14px;
        margin-bottom: 16px;
    }

    .events-display {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin: 20px 0;
    }

    .events-column {
        background: #1a1a1a;
        border-radius: 8px;
        padding: 16px;
    }

    .events-column h3 {
        margin-top: 0;
        margin-bottom: 12px;
        color: #fff;
        font-size: 16px;
    }

    .search-input {
        width: 100%;
        padding: 8px 12px;
        background: #2a2a2a;
        border: 1px solid #333;
        border-radius: 4px;
        color: #fff;
        margin-bottom: 12px;
        box-sizing: border-box;
    }

    .events-list {
        max-height: 400px;
        overflow-y: auto;
    }

    .event-item {
        padding: 12px;
        background: #222;
        border-radius: 6px;
        margin-bottom: 8px;
        cursor: pointer;
        border: 2px solid transparent;
        transition: border-color 0.2s, background 0.2s;
    }

    .event-item:hover {
        background: #2a2a2a;
    }

    .event-item.selected {
        border-color: #22c55e;
        background: #1a2a1a;
    }

    .event-title {
        font-size: 14px;
        margin-bottom: 6px;
        line-height: 1.4;
    }

    .event-title a {
        color: #60a5fa;
        text-decoration: none;
    }

    .event-title a:hover {
        text-decoration: underline;
    }

    .event-meta {
        display: flex;
        gap: 12px;
        font-size: 12px;
        color: #666;
    }

    .manual-event-match-section {
        display: flex;
        align-items: center;
        gap: 16px;
        margin: 16px 0;
        padding: 16px;
        background: #1a1a1a;
        border-radius: 8px;
    }

    .match-filter-section {
        margin: 16px 0;
    }

    .match-filters {
        display: flex;
        gap: 20px;
    }

    .filter-input-group {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .filter-input-group label {
        color: #888;
        font-size: 14px;
    }

    .filter-input {
        padding: 8px 12px;
        background: #2a2a2a;
        border: 1px solid #333;
        border-radius: 4px;
        color: #fff;
        width: 120px;
    }

    .event-cell {
        max-width: 300px;
    }

    .event-cell a {
        color: #60a5fa;
        text-decoration: none;
    }

    .event-cell a:hover {
        text-decoration: underline;
    }

    .verified-badge {
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
    }

    .verified-badge.verified {
        background: #14532d;
        color: #22c55e;
    }

    .verified-badge.unverified {
        background: #333;
        color: #888;
    }

    .actions-cell {
        white-space: nowrap;
    }

    .matched-tags-list {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }

    .tag-match-item {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        background: #222;
        border-radius: 4px;
        padding: 6px 10px;
        font-size: 13px;
    }

    .tag-match-item .match-arrow {
        color: #666;
    }

    @media (max-width: 900px) {
        .events-display {
            grid-template-columns: 1fr;
        }
    }
</style>
{% endblock %}

{% block scripts %}
<script>
    const currentSort = '{{ current_sort }}';
    let selectedKalshiEvent = null;
    let selectedPolymarketEvent = null;

    function sortBy(column) {
        let newSort = column;
        if (currentSort === column) {
            newSort = '-' + column;
        } else if (currentSort === '-' + column) {
            newSort = column;
        } else {
            newSort = '-' + column;
        }
        window.location.href = '?sort=' + newSort;
    }

    // Event selection
    function selectEvent(element, exchange) {
        const eventId = element.dataset.id;

        if (exchange === 'kalshi') {
            if (selectedKalshiEvent === eventId) {
                selectedKalshiEvent = null;
                element.classList.remove('selected');
            } else {
                document.querySelectorAll('#kalshiEventsList .event-item.selected').forEach(el => {
                    el.classList.remove('selected');
                });
                selectedKalshiEvent = eventId;
                element.classList.add('selected');
            }
        } else {
            if (selectedPolymarketEvent === eventId) {
                selectedPolymarketEvent = null;
                element.classList.remove('selected');
            } else {
                document.querySelectorAll('#polymarketEventsList .event-item.selected').forEach(el => {
                    el.classList.remove('selected');
                });
                selectedPolymarketEvent = eventId;
                element.classList.add('selected');
            }
        }

        updateEventMatchButton();
    }

    function updateEventMatchButton() {
        const btn = document.getElementById('createEventMatchBtn');
        const info = document.getElementById('selectedEventsInfo');

        if (selectedKalshiEvent && selectedPolymarketEvent) {
            btn.disabled = false;
            info.textContent = 'Ready to create match';
            info.style.color = '#22c55e';
        } else if (selectedKalshiEvent) {
            btn.disabled = true;
            info.textContent = 'Select a Polymarket event';
            info.style.color = '#888';
        } else if (selectedPolymarketEvent) {
            btn.disabled = true;
            info.textContent = 'Select a Kalshi event';
            info.style.color = '#888';
        } else {
            btn.disabled = true;
            info.textContent = 'Select one event from each exchange';
            info.style.color = '#888';
        }
    }

    // Filter events by search
    function filterEvents(exchange) {
        const searchInput = document.getElementById(exchange === 'kalshi' ? 'kalshiEventSearch' : 'polymarketEventSearch');
        const eventsList = document.getElementById(exchange === 'kalshi' ? 'kalshiEventsList' : 'polymarketEventsList');
        const searchTerm = searchInput.value.toLowerCase();

        eventsList.querySelectorAll('.event-item').forEach(item => {
            const title = item.querySelector('.event-title').textContent.toLowerCase();
            if (title.includes(searchTerm)) {
                item.style.display = '';
            } else {
                item.style.display = 'none';
            }
        });
    }

    // Create manual event match
    async function createEventMatch() {
        if (!selectedKalshiEvent || !selectedPolymarketEvent) return;

        const btn = document.getElementById('createEventMatchBtn');
        const loading = document.getElementById('createEventMatchLoading');

        btn.disabled = true;
        loading.style.display = 'inline';

        try {
            const response = await fetch('/api/event-matches/create/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    kalshi_event_id: selectedKalshiEvent,
                    polymarket_event_id: selectedPolymarketEvent
                })
            });

            const data = await response.json();

            if (data.success) {
                showToast('Event match created');
                setTimeout(() => location.reload(), 500);
            } else {
                showToast('Error: ' + data.error, 'error');
            }
        } catch (e) {
            showToast('Network error: ' + e.message, 'error');
        } finally {
            btn.disabled = false;
            loading.style.display = 'none';
        }
    }

    // Verify event match
    async function verifyEventMatch(matchId) {
        try {
            const response = await fetch(`/api/event-matches/${matchId}/verify/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                }
            });

            const data = await response.json();

            if (data.success) {
                location.reload();
            } else {
                showToast('Error: ' + data.error, 'error');
            }
        } catch (e) {
            showToast('Network error: ' + e.message, 'error');
        }
    }

    // Delete event match
    async function deleteEventMatch(matchId) {
        if (!confirm('Delete this event match?')) return;

        try {
            const response = await fetch(`/api/event-matches/${matchId}/delete/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                }
            });

            const data = await response.json();

            if (data.success) {
                showToast('Event match deleted');
                setTimeout(() => location.reload(), 500);
            } else {
                showToast('Error: ' + data.error, 'error');
            }
        } catch (e) {
            showToast('Network error: ' + e.message, 'error');
        }
    }

    // Refresh event matches
    async function refreshEventMatches() {
        const btn = document.getElementById('refreshMatchesBtn');
        const loading = document.getElementById('refreshMatchesLoading');

        btn.disabled = true;
        loading.style.display = 'inline';

        const volumeMin = document.getElementById('volumeMin').value;
        const liquidityMin = document.getElementById('liquidityMin').value;

        try {
            const response = await fetch('/api/refresh/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    volume_min: volumeMin || null,
                    liquidity_min: liquidityMin || null
                })
            });

            const data = await response.json();

            if (data.success) {
                showToast(`Found ${data.matches_found} matches`);
                setTimeout(() => location.reload(), 1000);
            } else {
                showToast('Error: ' + data.error, 'error');
            }
        } catch (e) {
            showToast('Network error: ' + e.message, 'error');
        } finally {
            btn.disabled = false;
            loading.style.display = 'none';
        }
    }

    async function refreshTags() {
        const btn = document.getElementById('refreshTagsBtn');
        const loading = document.getElementById('refreshTagsLoading');

        btn.disabled = true;
        loading.style.display = 'inline';

        try {
            const response = await fetch('{% url "markets:refresh_tags" %}', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                }
            });

            const data = await response.json();

            if (data.success) {
                showToast(`Synced ${data.kalshi_synced} Kalshi tags, ${data.polymarket_synced} Polymarket tags`);
                setTimeout(() => location.reload(), 1000);
            } else {
                showToast('Error: ' + data.error, 'error');
            }
        } catch (e) {
            showToast('Network error: ' + e.message, 'error');
        } finally {
            btn.disabled = false;
            loading.style.display = 'none';
        }
    }

    async function createManualTagMatch() {
        const btn = document.getElementById('manualMatchBtn');
        const loading = document.getElementById('manualMatchLoading');

        const kalshiChecked = document.querySelectorAll('input[name="kalshi_tag"]:checked');
        const polyChecked = document.querySelectorAll('input[name="polymarket_tag"]:checked');

        if (kalshiChecked.length !== 1 || polyChecked.length !== 1) {
            showToast('Please select exactly one Kalshi tag and one Polymarket tag to create a match.', 'error');
            return;
        }

        const kalshiTagId = kalshiChecked[0].dataset.tagId;
        const polymarketTagId = polyChecked[0].dataset.tagId;

        btn.disabled = true;
        loading.style.display = 'inline';

        try {
            const response = await fetch('{% url "markets:create_tag_match" %}', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    kalshi_tag_id: parseInt(kalshiTagId),
                    polymarket_tag_id: parseInt(polymarketTagId)
                })
            });

            const data = await response.json();

            if (data.success) {
                showToast('Tag match created');
                setTimeout(() => location.reload(), 500);
            } else {
                showToast('Error: ' + data.error, 'error');
            }
        } catch (e) {
            showToast('Network error: ' + e.message, 'error');
        } finally {
            btn.disabled = false;
            loading.style.display = 'none';
        }
    }

    async function deleteTagMatch(matchId) {
        if (!confirm('Delete this tag match?')) return;

        try {
            const response = await fetch(`/api/tag-matches/${matchId}/delete/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                }
            });

            const data = await response.json();

            if (data.success) {
                showToast('Tag match deleted');
                setTimeout(() => location.reload(), 500);
            } else {
                showToast('Error: ' + data.error, 'error');
            }
        } catch (e) {
            showToast('Network error: ' + e.message, 'error');
        }
    }

    function getSelectedTags() {
        const kalshiTags = [];
        const polymarketTags = [];

        document.querySelectorAll('input[name="kalshi_tag"]:checked').forEach(cb => {
            kalshiTags.push(cb.value);
        });

        document.querySelectorAll('input[name="polymarket_tag"]:checked').forEach(cb => {
            polymarketTags.push(cb.value);
        });

        return { kalshiTags, polymarketTags };
    }

    function getSyncFilters() {
        const closeAfter = document.getElementById('closeAfterDate').value;
        const closeBefore = document.getElementById('closeBeforeDate').value;
        const volumeMin = document.getElementById('syncVolumeMin').value;
        const volumeMax = document.getElementById('syncVolumeMax').value;
        const liquidityMin = document.getElementById('syncLiquidityMin').value;
        const liquidityMax = document.getElementById('syncLiquidityMax').value;
        return { closeAfter, closeBefore, volumeMin, volumeMax, liquidityMin, liquidityMax };
    }

    function clearSyncFilters() {
        document.getElementById('closeAfterDate').value = '';
        document.getElementById('closeBeforeDate').value = '';
        document.getElementById('syncVolumeMin').value = '';
        document.getElementById('syncVolumeMax').value = '';
        document.getElementById('syncLiquidityMin').value = '';
        document.getElementById('syncLiquidityMax').value = '';
    }

    async function syncEvents() {
        const btn = document.getElementById('syncBtn');
        const loading = document.getElementById('syncLoading');

        btn.disabled = true;
        loading.style.display = 'inline';

        try {
            const { kalshiTags, polymarketTags } = getSelectedTags();
            const { closeAfter, closeBefore, volumeMin, volumeMax, liquidityMin, liquidityMax } = getSyncFilters();

            const body = {};
            if (kalshiTags.length > 0) {
                body.kalshi_tags = kalshiTags;
            }
            if (polymarketTags.length > 0) {
                body.polymarket_tags = polymarketTags;
            }
            if (closeAfter) {
                body.close_after = closeAfter;
            }
            if (closeBefore) {
                body.close_before = closeBefore;
            }
            if (volumeMin) {
                body.volume_min = volumeMin;
            }
            if (volumeMax) {
                body.volume_max = volumeMax;
            }
            if (liquidityMin) {
                body.liquidity_min = liquidityMin;
            }
            if (liquidityMax) {
                body.liquidity_max = liquidityMax;
            }

            const response = await fetch('{% url "markets:sync_markets" %}', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(body)
            });

            const data = await response.json();

            if (data.success) {
                showToast(`Synced: ${data.kalshi_synced} Kalshi, ${data.polymarket_synced} Polymarket events`);
                setTimeout(() => location.reload(), 1500);
            } else {
                showToast('Error: ' + data.error, 'error');
            }
        } catch (e) {
            showToast('Network error: ' + e.message, 'error');
        } finally {
            btn.disabled = false;
            loading.style.display = 'none';
        }
    }

    async function syncFromMatchedTags() {
        const btn = document.getElementById('syncMatchedBtn');
        const loading = document.getElementById('syncMatchedLoading');

        // Get all matched tags
        const kalshiTags = [];
        const polyTags = [];

        {% for match in tag_matches %}
            kalshiTags.push('{{ match.kalshi_tag.slug }}');
            polyTags.push('{{ match.polymarket_tag.external_id }}');
        {% endfor %}

        if (kalshiTags.length === 0 && polyTags.length === 0) {
            showToast('No matched tags available. Create tag matches first.', 'error');
            return;
        }

        btn.disabled = true;
        loading.style.display = 'inline';

        try {
            const { closeAfter, closeBefore, volumeMin, volumeMax, liquidityMin, liquidityMax } = getSyncFilters();

            const body = {
                kalshi_tags: kalshiTags,
                polymarket_tags: polyTags
            };
            if (closeAfter) {
                body.close_after = closeAfter;
            }
            if (closeBefore) {
                body.close_before = closeBefore;
            }
            if (volumeMin) {
                body.volume_min = volumeMin;
            }
            if (volumeMax) {
                body.volume_max = volumeMax;
            }
            if (liquidityMin) {
                body.liquidity_min = liquidityMin;
            }
            if (liquidityMax) {
                body.liquidity_max = liquidityMax;
            }

            const response = await fetch('{% url "markets:sync_markets" %}', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(body)
            });

            const data = await response.json();

            if (data.success) {
                showToast(`Synced from matched tags: ${data.kalshi_synced} Kalshi, ${data.polymarket_synced} Polymarket events`);
                setTimeout(() => location.reload(), 1500);
            } else {
                showToast('Error: ' + data.error, 'error');
            }
        } catch (e) {
            showToast('Network error: ' + e.message, 'error');
        } finally {
            btn.disabled = false;
            loading.style.display = 'none';
        }
    }

    async function addTag(exchange) {
        let label, category = '';

        if (exchange === 'kalshi') {
            label = document.getElementById('kalshiTagInput').value.trim();
            category = document.getElementById('kalshiCategoryInput').value.trim();
        } else {
            label = document.getElementById('polymarketTagInput').value.trim();
        }

        if (!label) {
            showToast('Please enter a tag label.', 'error');
            return;
        }

        try {
            const response = await fetch('{% url "markets:create_tag" %}', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    exchange: exchange,
                    label: label,
                    category: category
                })
            });

            const data = await response.json();

            if (data.success) {
                showToast(`Tag "${label}" created`);
                setTimeout(() => location.reload(), 500);
            } else {
                showToast('Error: ' + data.error, 'error');
            }
        } catch (e) {
            showToast('Network error: ' + e.message, 'error');
        }
    }

    async function deleteTag(tagId, tagLabel) {
        if (!confirm(`Delete the tag "${tagLabel}"?`)) return;

        try {
            const response = await fetch(`/api/tags/${tagId}/delete/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCookie('csrftoken'),
                }
            });

            const data = await response.json();

            if (data.success) {
                showToast(data.message);
                setTimeout(() => location.reload(), 500);
            } else {
                showToast('Error: ' + data.error, 'error');
            }
        } catch (e) {
            showToast('Network error: ' + e.message, 'error');
        }
    }
</script>
{% endblock %}
